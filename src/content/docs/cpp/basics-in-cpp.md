---
title: Basics in C++
date: 20/8/2024
---


### Namespace
Namespace is a declarative region that provides a scope to the identifiers(the name of types, functions, variables, classes, methods). 

Namespaces are used to organize code into logical groups and to prevent name collisions that can occur especially when your code base includes multiple libraries. 

```c++
namespace myns
{
    int gi = 100;
    int var = 5;
    namespace myns_nested
    {
        int gi = 200;
    }
    void func1(void)
    {
        cout << "Inside func1 - myns namespace\n";
    }
}

namespace myns01
{
    double var = 3.14;
}

int main(void)
{
    cout << "&myns gi = " << &myns::gi << "\n";
    using namespace myns;
    cout << "myns gi = " << gi << "\n";
    cout << "myns_nested gi = " << myns_nested::gi << "\n";
    int x;
    x = var + myns01::var;
    cout <<"sum of \"var + myns01::var\" = "<< x << endl;
    func1();
}
```

### `nullptr`

The nullptr keyword specifies a null pointer constant of type `std::nullptr_t``, which is convertible to any raw pointer type


## Default Arguments in functions

To provide default values for functions.

```c++
int sum(int x, int y, int z = 100)
{
    return (x + y + z);
}

int main(void)
{
    int x = 10;
    int y = 20;
    int z = 30;
    cout<<sum(x,y,z)<<"\n";
    cout<<sum(x,y)<<"\n";
    return 0;
}
```
#### Things to know
1. Default args must be constant (Macros allowed)
```c++
void fun(int x, int y = 10); //Valid

void fun(int x, int y = x); // Not Valid
```

2. Declare and define

```c++
// MyHeader.h
void fun(int x, int y = 10);
```

```c++
// MySrc.cpp
void fun(int x, int y){
}
```

3. Right to left
```c++
void fun(int x, int y = 10); //Valid

void fun(int x = 0, int y); // Not Valid
```
4. If a function has last parameter with default value, then the same function cannot have a overloaded function with 2 args with same datatype.

```c++
int sum(int x, int y, int z = 100)
{
    return (x + y + z);
}

int sum(int a, int b) // Not allowed
{
    return (a + b);
}

int main(void)
{
    int x = 10;
    int y = 20;
    int z = 30;
    cout << sum(x, y, z) << "\n";
    cout << sum(x, y) << "\n"; // error
        //  ^ more than one instance of overloaded function "sum" matches the argument list:
    return 0;
}
```

***

### Templates
Templates allows user to write __generic functions__ and __classes__ that can be used for different data types.

Two types
1. Function Templates
2. Class Templates

#### Function templates

```c++ 
template <typename T> T getMax(T x, T y)
{
    return (x > y ? x : y);
}

template <typename T> void print(T x, T y)
{
    cout<<"x = "<<x<<", y = "<<y<<"\n";
}

int main(void)
{
    int xi = 10, yi = 20;
    double xd = 10.5, yd = 20.5;
    cout<<getMax<int>(xi, yi) << "\n";
    cout<<getMax<double>(xd, yd) << "\n";
    print<int>(xi, yi);
    return 0;
}
```

## Imp Topics / Questions

1. What Are the Functions That Are Generated by the Compiler by Default, If We Do Not Provide Them Explicitly?

    1. Default Constructor
    2. Copy Constructor
    3. Move Constructors
    4. Assignment Operator
    5. Destructor